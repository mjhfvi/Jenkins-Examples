pipeline {
    agent none

    environment {
        WINDOWS_NODE=""                                      // Use for the Windows build process, node: SRVCOMPILE7 or dynamically with tags Docker && Windows TBD
        LINUX_NODE=""                               // Use for the Linux build process, node: LinuxDockerCompile01 or dynamically with tags Docker && Linux TBD
        WINDOWS_IMAGE=""                // Name of the windows Docker Image to use, you should only change the project name
        LINUX_IMAGE=""                    // Name of the Linux Docker Image to use, you should only change the project name
        DOCKER_WINDOWS_DIR="Docker\\windows\\Dockerfile"                         // path to the windows dockerfile
        DOCKER_LINUX_DIR="Docker/linux/Dockerfile"                      // path to the Linux dockerfile
        TAG_SCRIPT_PATH=""                                 // path to the tag python file
        GIT_REPOSITORY=""                               // can use the ${JOB_NAME} variables is the jog have the same name TBD
        GIT_LOGIN_CREDENTIALS=""
        NEXUS_REGISTRY=""
        NEXUS_DOCKER_REGISTRY=""
        NEXUS_REGISTRY_LOGIN_CREDENTIALS=""
        DOCKER_BUILDKIT="0"                                             // Fixing "failed to solve with frontend dockerfile.v0" windows error
        RUN_STAGE_BUILD_WINDOWS="true"                                  // Build Windows Environment, use boolean expression true/false
        RUN_STAGE_BUILT_LINUX="true"                                    // Build Linux Environment, use boolean expression true/false
        RUN_STAGE_DEPLOY="true"                                         // Depoly Image to QA Stage, use boolean expression true/false
        RUN_STAGE_CLEANUP="true"                                        // Cleanup Image Stage, use boolean expression true/false
        EMAIL_LIST_DEFAULT=""                           // Email Notification List
        TEAMS_URL=""
        // TRIGGER_TOKEN="InstrumentServer_token"                       // Project Trigger Token from BitBucket
        CONSUL_IMAGE_ID=""                          // Consul K/V Name in QA Environment
    }

    parameters {
        // string ( name: 'BRANCH_TO_RUN', defaultValue: 'dev', description: 'Name of Branch to run', trim: false )
        choice ( name: 'BRANCH_TO_RUN', choices: ['dev', 'Releases/1.0'], description: 'Select a Branch to run')
        // string ( name: 'DOCKER_IMAGE_NODE_VERSION', defaultValue: '16.16.0', description: 'Node Version to Run in Docker.', trim: false )
    }

    options {
        timeout(time: 1, unit: 'HOURS')                                 // Overall Time for the Build to Run
        skipStagesAfterUnstable()
        ansiColor('xterm')
        retry(3)
    }

    triggers {
        GenericTrigger (
            genericVariables: [ [key: 'ref', value: '$.ref'] ],
            token: 'InstrumentServer_token',                            // testing '${env.TRIGGER_TOKEN}'
            causeString: 'Triggered by $.actor.displayName for BitBucket Project $ref from $branch',
            printContributedVariables: true,
            printPostContent: true
        )
    }

    stages {
        stage('Tag') {
            agent any
            steps {
                timeout(time: 2, unit: 'MINUTES') {
                    print("Generate Version Tag for This Build")
                    script {
                        try {
                            script{
                                print("Downloading Git Source Code for Image Tagging, Working on Branch ${params.BRANCH_TO_RUN}")
                                checkout([$class: 'GitSCM',
                                branches: [[name: "${params.BRANCH_TO_RUN}"]],
                                userRemoteConfigs: [[credentialsId: "${env.GIT_LOGIN_CREDENTIALS}",
                                url: "SERVER_URL${env.GIT_REPOSITORY}.git"]]])
                                if(isUnix()) {
                                    SHORT_COMMIT = sh (script: "git log -1 --format=%h --abbrev=10", returnStdout: true).trim()
                                    print("Get Short Commit Number for Build - ${SHORT_COMMIT}")
                                    GET_COMMIT_EMAIL = sh (script: 'git log -1 --pretty=%cn ${SHORT_COMMIT}', returnStdout: true).trim()
                                    print("Committer Email from GIT - ${GET_COMMIT_EMAIL}")
                                } else {
                                    GET_COMMIT = bat (script: "git log -1 --format=%%h --abbrev=10", returnStdout: true).trim()
                                    SHORT_COMMIT = GET_COMMIT.readLines().drop(1).join(" ")
                                    print("Get Short Commit Number for Build - ${SHORT_COMMIT}")
                                    GET_COMMIT_EMAIL = bat (script: 'git --no-pager show -s --format=\'%%ae\'', returnStdout: true).trim()
                                    GIT_COMMIT = GET_COMMIT_EMAIL.readLines().drop(1).join(" ")
                                    print("Committer Email from GIT - ${GIT_COMMIT}")
                                    }
                            }
                            if (params.BRANCH_TO_RUN == 'master') {
                                print("We Dont Run Branch - ${params.BRANCH_TO_RUN} !!!")
                                currentBuild.result = 'ABORTED'
                                script{exit 1}
                            }
                            if (params.BRANCH_TO_RUN == 'dev') {
                                print("Building from Branch - ${params.BRANCH_TO_RUN}")
                                script { DOCKER_IMAGE_TAG_DEV = 'dev-'+SHORT_COMMIT; }
                                print("Release Label For Dockerfile - ${DOCKER_IMAGE_TAG_DEV}")
                                cleanWs()
                                TagStage = 'SUCCESS'
                                return
                            }
                            if (params.BRANCH_TO_RUN == 'REGRESSION' ) {
                                print("Building from Branch - ${params.BRANCH_TO_RUN}")
                            }
                            if (params.BRANCH_TO_RUN ==~ /Releases.*/ ) {
                                print("Building from Branch - ${params.BRANCH_TO_RUN}")
                                print("Starting the Tag Process for Release")
                                script {
                                    if(isUnix()) {
                                        sh (script: "python3 -u ./devops/tag.py ${env.BRANCH_TO_RUN} ${SHORT_COMMIT} SERVER_URL${env.GIT_REPOSITORY}.git", returnStdout: true).trim()
                                        DOCKER_IMAGE_TAG_RELEASE = sh (script: "@git describe --tags ${SHORT_COMMIT}", returnStdout: true).trim()
                                        print("Testing tag version: ${DOCKER_IMAGE_TAG_RELEASE}")
                                    } else {
                                        bat (script: "python -u ./devops/tag.py ${env.BRANCH_TO_RUN} ${SHORT_COMMIT} SERVER_URL${env.GIT_REPOSITORY}.git",label: 'Run Tag Script', returnStdout: true).trim()
                                        DOCKER_IMAGE_TAG_RELEASE = bat (script: "@git describe --tags ${SHORT_COMMIT}",label: 'Print Tag Information', returnStdout: true).trim()
                                        print("Release Label For Dockerfile - ${DOCKER_IMAGE_TAG_RELEASE}")
                                        }
                                }
                            cleanWs()
                            TagStage = 'SUCCESS'
                            return
                            } else {
                                print("I Dont Know What to do With Branch - ${params.BRANCH_TO_RUN}..")
                                cleanWs()
                                currentBuild.result = 'ABORTED'
                                return
                            }
                        } catch (err) {
                                print (err)
                                print ("Got an Error, Dont Know How To Continue.. EXIT BUILD")
                                script{exit 1}
                                currentBuild.result='FAILURE'
                                return
                        }
                    }
                }
            }
            post {
                failure {
                    print("Tag Proccess is a Failure, Sending Email Notifications to ${env.EMAIL_LIST_DEFAULT}")
                    script{
                        try {
                            NOTIFY_EMAIL("${env.EMAIL_LIST_DEFAULT}", "Build is a Failure")
                            print("Sending Teams Notifications")
                            // NOTIFY_TEAMS("ff0008")
                        } catch (err) {
                            print (err)
                            print ("Got an Error, Dont Know How To Continue..")
                            currentBuild.result='FAILURE'
                            return
                            }
                    }
                }
            }
        }
            stage('Parallel') { when { expression { TagStage == 'SUCCESS' } }
            parallel {
                stage('Windows') { when { expression { env.RUN_STAGE_BUILD_WINDOWS.toBoolean() } }
                    agent { label "${WINDOWS_NODE}" }
                    stages {
                        stage('Git') {
                            steps {
                                timeout(time: 2, unit: 'MINUTES') {
                                    print("Downloading Git Source Code, Working on Branch ${params.BRANCH_TO_RUN}")
                                    checkout([$class: 'GitSCM',
                                    branches: [[name: "${params.BRANCH_TO_RUN}"]],
                                    userRemoteConfigs: [[credentialsId: "${env.GIT_LOGIN_CREDENTIALS}",
                                    url: "SERVER_URL${env.GIT_REPOSITORY}.git"]]])
                                }
                            }
                        }
                        stage('Build Image') {
                            steps {
                                timeout(time: 15, unit: 'MINUTES') {
                                    script {
                                        try {
                                            if (params.BRANCH_TO_RUN == 'dev') {
                                                script{
                                                    print("Building Windows Docker Image - '${env.WINDOWS_IMAGE}'")
                                                    print("Building Dockerfile Using Tag Version - dev")
                                                    WINDOWS_DOCKER_IMAGE_DEV = docker.build("${env.WINDOWS_IMAGE}:dev", "-f ${env.DOCKER_WINDOWS_DIR} .")

                                                    print("Tagging Dockerfile Using Tag Version - '${DOCKER_IMAGE_TAG_DEV}'")
                                                    bat ("docker tag ${env.WINDOWS_IMAGE}:dev ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_DEV}")

                                                    print("Tagging Dockerfile for Nexus Repository")
                                                    WINDOWS_DOCKER_IMAGE_DEV_NEXUS              = bat ("docker tag ${env.WINDOWS_IMAGE}:dev ${NEXUS_DOCKER_REGISTRY}${env.WINDOWS_IMAGE}:dev")
                                                    WINDOWS_DOCKER_IMAGE_TAG_SHORT_COMMIT_NEXUS = bat ("docker tag ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_DEV} ${NEXUS_DOCKER_REGISTRY}${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_DEV}")
                                                    WindowsBuildStage = 'SUCCESS'
                                                }
                                            }
                                            if (params.BRANCH_TO_RUN ==~ /Releases.*/ ) {
                                                script{
                                                    print("Building Windows Docker Image - '${env.WINDOWS_IMAGE}'")
                                                    print("Building Dockerfile Using Tag Version - Latest")
                                                    WINDOWS_DOCKER_IMAGE_LATEST = docker.build("${env.WINDOWS_IMAGE}:latest", "-f ${env.DOCKER_WINDOWS_DIR} .")

                                                    print("Tagging Docker Image Using Tag Version - '${DOCKER_IMAGE_TAG_RELEASE}'")
                                                    bat ("docker tag ${env.WINDOWS_IMAGE}:latest ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE}")

                                                    print("Tagging Docker Image for Nexus Repository")
                                                    WINDOWS_DOCKER_IMAGE_LATEST_NEXUS      = bat ("docker tag ${env.WINDOWS_IMAGE}:latest ${NEXUS_DOCKER_REGISTRY}${env.WINDOWS_IMAGE}:latest")
                                                    WINDOWS_DOCKER_IMAGE_TAG_RELEASE_NEXUS = bat ("docker tag ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE} ${NEXUS_DOCKER_REGISTRY}${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE}")
                                                    WindowsBuildStage = 'SUCCESS'
                                                }
                                            }
                                        } catch (err) {
                                                print (err)
                                                print ("Got an Error, Dont Know How To Continue..")
                                                currentBuild.result='FAILURE'
                                                return
                                        }
                                    }
                                }
                            }
                        }
                        // stage('Test Image') { when { expression { WindowsBuildStage == 'SUCCESS' } }
                        //     steps {
                        //         timeout(time: 5, unit: 'MINUTES') {
                        //             script {
                        //                 try {
                        //                     if (params.BRANCH_TO_RUN == 'dev') {
                        //                         script {
                        //                             try {
                        //                                 print("Testing '${env.WINDOWS_IMAGE}:dev' image")
                        //                                 WINDOWS_DOCKER_IMAGE_DEV.inside { bat 'dir'}
                        //                                 if (manager.logContains(".*config.js.*") && (".*tslint.json.*") && (".*webpack.config.js.*")) {
                        //                                     print("Found Test Files config.js, tslint.json, webpack.config.js, Docker Image Test Past Successful")
                        //                                     WindowsTestStage = 'SUCCESS'
                        //                                     } else {
                        //                                         print("Docker Image Test Failed Miserably...")
                        //                                         currentBuild.result = "FAILURE"
                        //                                         }
                        //                             }
                        //                             catch (Exception err) {
                        //                                 echo 'Exception occurred: ' + err.toString()
                        //                                 throw err
                        //                             }
                        //                         }
                        //                     }
                        //                     if (params.BRANCH_TO_RUN ==~ /Releases.*/ ) {
                        //                         script {
                        //                             try {
                        //                                 print("Testing '${env.WINDOWS_IMAGE}:latest' image")
                        //                                 WINDOWS_DOCKER_IMAGE_LATEST.inside { bat 'dir' }
                        //                                 if (manager.logContains(".*config.js.*") && (".*tslint.json.*") && (".*webpack.config.js.*")) {
                        //                                 print("Found Test Files config.js, tslint.json, webpack.config.js, Docker Image Test Past Successful")
                        //                                 WindowsTestStage = 'SUCCESS'
                        //                                 } else {
                        //                                     print("Docker Image Test Failed Miserably...")
                        //                                     currentBuild.result = "FAILURE"
                        //                                     }
                        //                             }
                        //                             catch (Exception err) {
                        //                                 echo 'Exception occurred: ' + err.toString()
                        //                                 throw err
                        //                             }
                        //                         }
                        //                     }
                        //                 } catch (err) {
                        //                             print (err)
                        //                             print ("Got an Error, Dont Know How To Continue..")
                        //                             currentBuild.result='FAILURE'
                        //                             return
                        //                 }
                        //             }
                        //         }
                        //     }
                        // }
                        stage('Push Image') { //when { expression { WindowsTestStage == 'SUCCESS' } }
                            steps {
                                timeout(time: 5, unit: 'MINUTES') {
                                    script {
                                        try {
                                            if (params.BRANCH_TO_RUN == 'dev') {
                                                script{
                                                    print("Pushing Windows Docker Image ${env.WINDOWS_IMAGE} to Docker Hub")
                                                    bat ("docker push ${env.WINDOWS_IMAGE}:dev")

                                                    print("Pushing Windows Docker Image ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_DEV} to Docker Hub")
                                                    bat ("docker push ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_DEV}")

                                                    print("Pushing Windows Docker Image ${env.WINDOWS_IMAGE}:dev to Nexus Repository")
                                                    bat ("docker push ${NEXUS_DOCKER_REGISTRY}${env.WINDOWS_IMAGE}:dev")

                                                    print("Pushing Windows Docker Image ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_DEV} to Nexus Repository")
                                                    bat ("docker push ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_DEV}")
                                                    WindowsPushStage = 'SUCCESS'
                                                }
                                            }
                                            if (params.BRANCH_TO_RUN ==~ /Releases.*/ ) {
                                                script{
                                                    print("Pushing Windows Docker Image ${env.WINDOWS_IMAGE} to Docker Hub")
                                                    bat ("docker push ${env.WINDOWS_IMAGE}:latest")

                                                    print("Pushing Windows Docker Image ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE} to Docker Hub")
                                                    bat ("docker push ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE}")

                                                    print("Pushing Windows Docker Image ${env.WINDOWS_IMAGE}:latest to Nexus Repository")
                                                    bat ("docker push ${NEXUS_DOCKER_REGISTRY}${env.WINDOWS_IMAGE}:latest")

                                                    print("Pushing Windows Docker Image ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE} to Nexus Repository")
                                                    bat ("docker push ${NEXUS_DOCKER_REGISTRY}${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE}")
                                                    WindowsPushStage = 'SUCCESS'
                                                }
                                            }

                                        } catch (err) {
                                                print (err)
                                                print ("Got an Error, Dont Know How To Continue..")
                                                currentBuild.result='FAILURE'
                                                return
                                        }
                                    }
                                }
                            }
                        }
                        stage("Cleanup") { when { expression { env.RUN_STAGE_CLEANUP.toBoolean() } }
                            steps {
                                timeout(time: 5, unit: 'MINUTES') {
                                    catchError {
                                        script{
                                            try {
                                                if (params.BRANCH_TO_RUN == 'dev') {
                                                    print("Removing Docker Image latest")
                                                    bat (script: "docker rmi ${env.WINDOWS_IMAGE}:dev")
                                                    print("Removing Docker Image ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_DEV}")
                                                    bat (script: "docker rmi ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_DEV}")
                                                }
                                                if (params.BRANCH_TO_RUN ==~ /Releases.*/ ) {
                                                    print("Removing Docker Image latest")
                                                    bat (script: "docker rmi ${env.WINDOWS_IMAGE}:latest")
                                                    print("Removing Docker Image ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE}")
                                                    bat (script: "docker rmi ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE}")
                                                }
                                            } catch (err) {
                                                    print (err)
                                                    print ("Got an Error, Dont Know How To Continue..")
                                                    currentBuild.result='FAILURE'
                                                    return
                                                }
                                            cleanWs()
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                stage('Linux') { when { expression { env.RUN_STAGE_BUILT_LINUX.toBoolean() } }
                agent { label "${LINUX_NODE}" }
                    stages {
                        stage('Git') {
                            steps {
                                timeout(time: 2, unit: 'MINUTES') {
                                    print("Downloading Git Source Code, Working on Branch ${params.BRANCH_TO_RUN}")
                                    checkout([$class: 'GitSCM',
                                    branches: [[name: "${params.BRANCH_TO_RUN}"]],
                                    userRemoteConfigs: [[credentialsId: "${env.GIT_LOGIN_CREDENTIALS}",
                                    url: "SERVER_URL${env.GIT_REPOSITORY}.git"]]])
                                }
                            }
                        }
                        stage('Build Image') {
                            steps {
                                timeout(time: 10, unit: 'MINUTES') {
                                    script{
                                        try {
                                            if (params.BRANCH_TO_RUN == 'dev') {
                                                script{
                                                    print("Building Linux Docker Image - '${env.LINUX_IMAGE}'")
                                                    print("Building Dockerfile Using Tag Version - dev")
                                                    LINUX_DOCKER_IMAGE_DEV = docker.build("${env.LINUX_IMAGE}:dev", "-f ${env.DOCKER_LINUX_DIR} .")

                                                    print("Tagging Docker Image Using Tag Version - '${DOCKER_IMAGE_TAG_DEV}'")
                                                    sh ("docker tag ${env.LINUX_IMAGE}:dev ${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_DEV}")

                                                    print("Tagging Docker Image for Nexus Repository")
                                                    sh ("docker tag ${env.LINUX_IMAGE}:dev ${NEXUS_DOCKER_REGISTRY}${env.LINUX_IMAGE}:dev")
                                                    LINUX_DOCKER_IMAGE_DEV_NEXUS = "${NEXUS_DOCKER_REGISTRY}${env.LINUX_IMAGE}:dev"

                                                    sh ("docker tag ${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_DEV} ${NEXUS_DOCKER_REGISTRY}${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_DEV}")
                                                    LINUX_DOCKER_IMAGE_TAG_SHORT_COMMIT_NEXUS = "${NEXUS_DOCKER_REGISTRY}${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_DEV}"
                                                    LinuxBuildStage = 'SUCCESS'
                                                }
                                            }
                                            if (params.BRANCH_TO_RUN ==~ /Releases.*/ ) {
                                                script{
                                                    print("Building Linux Docker Image - '${env.LINUX_IMAGE}'")
                                                    print("Building Dockerfile Using Tag Version - latest")
                                                    LINUX_DOCKER_IMAGE_LATEST = docker.build("${env.LINUX_IMAGE}:latest", "-f ${env.DOCKER_LINUX_DIR} .")

                                                    print("Tagging Docker Image Using Tag Version - '${DOCKER_IMAGE_TAG_RELEASE}'")
                                                    sh ("docker tag ${env.LINUX_IMAGE}:latest ${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE}")

                                                    print("Tagging Docker Image for Nexus Repository")
                                                    sh ("docker tag ${env.LINUX_IMAGE}:latest ${NEXUS_DOCKER_REGISTRY}${env.LINUX_IMAGE}:latest")
                                                    LINUX_DOCKER_IMAGE_LATEST_NEXUS = "${NEXUS_DOCKER_REGISTRY}${env.LINUX_IMAGE}:latest"

                                                    sh ("docker tag ${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE} ${NEXUS_DOCKER_REGISTRY}${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE}")
                                                    LINUX_DOCKER_IMAGE_TAG_RELEASE_NEXUS = "${NEXUS_DOCKER_REGISTRY}${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE}"
                                                    LinuxBuildStage = 'SUCCESS'
                                                }
                                            }
                                        } catch (err) {
                                                print (err)
                                                print ("Got an Error, Dont Know How To Continue..")
                                                currentBuild.result='FAILURE'
                                                return
                                        }
                                    }
                                }
                            }
                        }
                        // stage('Test Image') { when { expression { LinuxBuildStage == 'SUCCESS' } }
                        //     steps {
                        //         timeout(time: 5, unit: 'MINUTES') {
                        //             script {
                        //                 try {
                        //                     if (params.BRANCH_TO_RUN == 'dev') {
                        //                         script {
                        //                             print("Testing '${env.LINUX_IMAGE}:dev' image")
                        //                             try {
                        //                                 "${env.LINUX_IMAGE}:dev".inside { sh "ls" }
                        //                                 if (manager.logContains(".*config.js.*") && (".*tslint.json.*") && (".*webpack.config.js.*")) {
                        //                                     print("Found Test Files config.js, tslint.json, webpack.config.js, Docker Image Test Past Successful")
                        //                                     LinuxTestStage = 'SUCCESS'
                        //                                 } else {
                        //                                     print("Docker Image Test Failed Miserably...")
                        //                                     currentBuild.result = "FAILURE"
                        //                                     }
                        //                             }
                        //                             catch (Exception err) {
                        //                                 echo 'Exception occurred: ' + err.toString()
                        //                                 throw err
                        //                             }
                        //                         }
                        //                     }
                        //                     if (params.BRANCH_TO_RUN ==~ /Releases.*/ ) {
                        //                         script {
                        //                             print("Testing '${env.LINUX_IMAGE}:latest' image")
                        //                             try {
                        //                                 LINUX_DOCKER_IMAGE_LATEST.inside { sh "ls" }
                        //                                 if (manager.logContains(".*config.js.*") && (".*tslint.json.*") && (".*webpack.config.js.*")) {
                        //                                     print("Found Test Files config.js, tslint.json, webpack.config.js, Docker Image Test Past Successful")
                        //                                     LinuxTestStage = 'SUCCESS'
                        //                                 } else {
                        //                                     print("Docker Image Test Failed Miserably...")
                        //                                     currentBuild.result = "FAILURE"
                        //                                     }
                        //                             }
                        //                             catch (Exception err) {
                        //                                 echo 'Exception occurred: ' + err.toString()
                        //                                 throw err
                        //                             }
                        //                         }
                        //                     }
                        //                 } catch (err) {
                        //                             print (err)
                        //                             print ("Got an Error, Dont Know How To Continue..")
                        //                             currentBuild.result='FAILURE'
                        //                             return
                        //                 }
                        //             }
                        //         }
                        //     }
                        // }
                        stage('Push Image') { //when { expression { LinuxTestStage == 'SUCCESS' } }
                            steps {
                                timeout(time: 5, unit: 'MINUTES') {
                                    script{
                                        try {
                                            if (params.BRANCH_TO_RUN == 'dev') {
                                                script{
                                                    print("Pushing Linux Docker Image ${env.LINUX_IMAGE}:dev to Docker Hub")
                                                    sh ("docker push ${env.LINUX_IMAGE}:dev")

                                                    print("Pushing Linux Docker Image ${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_DEV} to Docker Hub")
                                                    sh ("docker push ${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_DEV}")

                                                    print("Pushing Linux Docker Image ${env.LINUX_IMAGE}:dev to Nexus Repository")
                                                    sh ("docker push ${NEXUS_DOCKER_REGISTRY}${env.LINUX_IMAGE}:dev")

                                                    print("Pushing Linux Docker Image ${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_DEV} to Nexus Repository")
                                                    sh ("docker push ${NEXUS_DOCKER_REGISTRY}${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_DEV}")
                                                    LinuxPushStage = 'SUCCESS'
                                                }
                                            }
                                            if (params.BRANCH_TO_RUN ==~ /Releases.*/ ) {
                                                script{
                                                    print("Pushing Linux Docker Image ${env.LINUX_IMAGE}:latest to Docker Hub")
                                                    sh ("docker push ${env.LINUX_IMAGE}:latest")

                                                    print("Pushing Linux Docker Image ${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE} to Docker Hub")
                                                    sh ("docker push ${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE}")

                                                    print("Pushing Linux Docker Image ${env.LINUX_IMAGE}:latest to Nexus Repository")
                                                    sh ("docker push ${NEXUS_DOCKER_REGISTRY}${env.LINUX_IMAGE}:latest")

                                                    print("Pushing Linux Docker Image ${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE} to Nexus Repository")
                                                    sh ("docker push ${NEXUS_DOCKER_REGISTRY}${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE}")
                                                    LinuxPushStage = 'SUCCESS'
                                                    }
                                            }
                                        } catch (err) {
                                                print (err)
                                                print ("Got an Error, Dont Know How To Continue..")
                                                currentBuild.result='FAILURE'
                                                return
                                        }
                                    }
                                }
                            }
                        }
                        stage("Cleanup") { when { expression { env.RUN_STAGE_CLEANUP.toBoolean() } }
                            steps {
                                timeout(time: 2, unit: 'MINUTES') {
                                    catchError {
                                        script{
                                            try {
                                                if (params.BRANCH_TO_RUN == 'dev') {
                                                    print("Removing Docker Image latest")
                                                    sh (script: "docker rmi ${env.LINUX_IMAGE}:dev")
                                                    print("Removing Docker Image ${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_DEV}")
                                                    sh (script: "docker rmi ${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_DEV}")
                                                }
                                                if (params.BRANCH_TO_RUN ==~ /Releases.*/ ) {
                                                    print("Removing Docker Image latest")
                                                    sh (script: "docker rmi ${env.LINUX_IMAGE}:latest")
                                                    print("Removing Docker Image ${env.WINDOWS_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE}")
                                                    sh (script: "docker rmi ${env.LINUX_IMAGE}:${DOCKER_IMAGE_TAG_RELEASE}")
                                                }
                                            } catch (err) {
                                                print (err)
                                                print ("Got an Error, Dont Know How To Continue..")
                                                currentBuild.result='FAILURE'
                                                return
                                                }
                                            cleanWs()
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        stage('Deploy to QA') { when { allOf { expression { LinuxPushStage == 'SUCCESS' && WindowsPushStage == 'SUCCESS' } } }
            agent any
            steps {
                timeout(time: 2, unit: 'MINUTES') {
                    script{
                        try {
                            if (params.BRANCH_TO_RUN == 'dev') {
                                print("Deploy Docker Image to Consul in QA Environment with Tag '${DOCKER_IMAGE_TAG_DEV}'")
                                if(isUnix()) {
                                    sh ("curl --silent --show-error --request PUT --data ${DOCKER_IMAGE_TAG_DEV} http://10.0.1.25:8500/v1/kv/${env.CONSUL_IMAGE_ID}")
                                    sh ("curl --silent --show-error --request PUT --data ${DOCKER_IMAGE_TAG_DEV} http://10.0.1.27:8500/v1/kv/${env.CONSUL_IMAGE_ID}")
                                } else {
                                    bat ("curl --silent --show-error --request PUT --data ${DOCKER_IMAGE_TAG_DEV} http://10.0.1.25:8500/v1/kv/${env.CONSUL_IMAGE_ID}")
                                    bat ("curl --silent --show-error --request PUT --data ${DOCKER_IMAGE_TAG_DEV} http://10.0.1.27:8500/v1/kv/${env.CONSUL_IMAGE_ID}")
                                }
                            }
                            if (params.BRANCH_TO_RUN ==~ /Releases.*/ ) {
                                print("We Dont Deploy Releases Branch to QA")
                            }
                        } catch (err) {
                            print (err)
                            print ("Got an Error, Dont Know How To Continue..")
                            currentBuild.result='FAILURE'
                            return
                            }
                    }
                }
            }
            post {
                success {
                    print("The Build is Successfully, Sending Email Notifications")
                    script{
                        if (params.BRANCH_TO_RUN == 'dev') {
                            manager.addShortText("${DOCKER_IMAGE_TAG_DEV}")
                        }
                        if (params.BRANCH_TO_RUN ==~ /Releases.*/ ) {
                            manager.addShortText("${params.BRANCH_TO_RUN} ${DOCKER_IMAGE_TAG_RELEASE}")
                        }
                    }
                }
            }
        }
    }
    post {      //  fixed, regression, unsuccessful, changed, always
        aborted {
            print("The Build is Aborted, Sending Email Notifications")
            script{
                NOTIFY_EMAIL("${env.EMAIL_LIST_DEFAULT}", "Build Was Aborted")
                // print("Sending Teams Notifications")
                // NOTIFY_TEAMS("968b87")
                manager.addShortText("Build Aborted")
            }
        }
        unstable {
            print("The Build is Unstable, Sending Email Notifications")
            script{
                // NOTIFY_EMAIL("${env.EMAIL_LIST_DEFAULT}", "Build is Unstable")
                print("Sending Teams Notifications")
                // NOTIFY_TEAMS("ff0008")
                manager.addShortText("Build Unstable on ${params.BRANCH_TO_RUN}")
            }
        }
        failure {
            print("The Build is a Failure, Sending Email Notifications")
            script{
                // NOTIFY_EMAIL("${env.EMAIL_LIST_DEFAULT}", "Build is a Failure")
                print("Sending Teams Notifications")
                // NOTIFY_TEAMS("ff0008")
                manager.addShortText("Failed Build on ${params.BRANCH_TO_RUN}")
            }
        }
        // success {                           // "SUCCESS", "UNSTABLE", "FAILURE", "NOT_BUILT", "ABORTED"
        //     print("The Build is Successfully, Sending Email Notifications")
        //     script{
        //          NOTIFY_EMAIL("${env.EMAIL_LIST_DEFAULT}", "Build Finish Successfully")
        //          print("Sending Teams Notifications")
        //          NOTIFY_TEAMS("00ff00")
        //          manager.addBadge("success.gif")
        //          manager.addShortText("${params.BRANCH_TO_RUN}")
        //     }
        // }
    }
}

def NOTIFY_EMAIL (EMAIL_ADDRESS, TEST_RESULT) {
    emailext (
        to: "${EMAIL_ADDRESS}",
        subject: "Job Result: Job '${env.JOB_NAME} - Build Number [${env.BUILD_NUMBER}]' - Status '${TEST_RESULT}'",
        body: """<p>Job Result: Job '${env.JOB_NAME} - Build Number [${env.BUILD_NUMBER}]' - Status '${TEST_RESULT}':</p>
            <p>Check console output at &QUOT;<a href='${env.BUILD_URL}'>${env.JOB_NAME} [${env.BUILD_NUMBER}]</a>&QUOT;</p>""",
        )
}

def NOTIFY_TEAMS (COLOR) {  // green 00ff00, red ff0008, blue 1d14c9, gray 968b87
    office365ConnectorSend (
        status: "Pipeline Status",
        webhookUrl: "${env.TEAMS_URL}",
        color: '${COLOR}',
        message: "Test Successful: ${JOB_NAME} - ${BUILD_DISPLAY_NAME}<br>Pipeline duration: ${currentBuild.durationString}"
    )
}
